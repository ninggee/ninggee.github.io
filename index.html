<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="凝戈">
<meta property="og:url" content="https://ninggee.github.io/index.html">
<meta property="og:site_name" content="凝戈">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="凝戈">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ninggee.github.io/"/>





  <title>凝戈</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">凝戈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">making a big fortune with no voice</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ninggee.github.io/2017/10/30/design-pattern-19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凝戈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/30/design-pattern-19/" itemprop="url">Pattern 19. State模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-30T13:49:54+08:00">
                2017-10-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式学习/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>Allow an object to alter its behavior when its internal state changes.The object will appear to change its class.</p>
</blockquote>
<p>状态模式，允许一个对象随着他的内部状态的变化改变其行为，就好像换了一个类一样。<br>状态模式的核心是封装，状态的变更引起了行为的变化，从外部看起来就好像这个对象对应的类发生了改变一样。下面来看状态模式是如何工作的</p>
<h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>考虑状态模式是如何工作的，就要先知道为什么出现状态模式，那么为什么状态模式会出现呢？<br>原因很简单，是因为在项目中有很多时候，一个类的行为会随着他的状态发生变化而变化，我们正常的想法是放很多的条件判断，判断当前的状态来确定行为，但是这样的方法多了以后，就会出现大量的条件语句块。对扩展性影响极大。为了解决这类问题，状态模式就应运而生了。<br>状态模式的重点是通过类来描述状态，一个类代表一种状态，那么为了提取状态类。我们就要知道一个对象有哪些随状态变化而变化的行为，找到这些行为，提取他们形成单独的状态类，就是状态模式最为核心的点。下面来看示例代码吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//state类状态类</span></div><div class="line"><span class="comment">//状态类定义自己的抽象方法，同时保存环境变量来实现状态的转换</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> Context __context;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set_context</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        __context = context;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//状态类定义的根据状态变化而行为不同的方法</span></div><div class="line">    <span class="comment">//一般和环境类中的方法对应</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//具体的状态类</span></div><div class="line"><span class="comment">//每个状态类都有两个任务</span></div><div class="line"><span class="comment">//一个是在自己状态下自己特有的行为</span></div><div class="line"><span class="comment">//另一个是行为发生后，利用环境类改变环境类的状态</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteState1</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">       System.out.println(<span class="string">"state 1 do method1"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.__context.setCurrentState(Context.state2);</div><div class="line">        __context.method2();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteState2</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">        __context.setCurrentState(Context.state1);</div><div class="line">        __context.method1();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"state2 do method2"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//环境类</span></div><div class="line"><span class="comment">//环境类负责定义对外暴露的接口</span></div><div class="line"><span class="comment">//这些接口基本和状态类中的方法对应，因为都是随状态变化行为不同的方法</span></div><div class="line"><span class="comment">//除此之外还要提供改变环境类状态的方法。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> State state1 = <span class="keyword">new</span> ConcreteState1();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> State state2 = <span class="keyword">new</span> ConcreteState2();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> State currentState ;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(State currentState)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.currentState = currentState;</div><div class="line">        <span class="keyword">this</span>.currentState.set_context(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> currentState;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.currentState.method1();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.currentState.method2();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码示例看起来有一点绕，但是我们搞清楚各个角色的任务之后，就会发现这些代码正是状态模式应有的模样。<br>我们要注意两点，是状态模式在实现的时候约定俗成的规则：</p>
<ul>
<li>把环境类的所有可能的状态列为类的静态常量</li>
<li>环境角色有状态类的所有的随状态变化而变化的方法，在方法内使用委托来调用具体的状态类的方法。</li>
</ul>
<p>下面是状态模式的图示：</p>
<p><img src="http://wx1.sinaimg.cn/mw690/e488f771gy1fl0875bch5j20d608uq3o.jpg" alt="C9223BBF-336F-47A2-BD65-EA4F74FEC83D.png"></p>
<h3 id="状态模式中的角色"><a href="#状态模式中的角色" class="headerlink" title="状态模式中的角色"></a>状态模式中的角色</h3><ol>
<li><code>context</code>：环境类负责定义对外暴露的接口，这些接口基本和状态类中的方法对应，因为都是随状态变化行为不同的方法，除此之外还要提供改变环境类状态的方法。</li>
<li><code>State</code>：抽象的状态类，定义自己的抽象方法，同时保存环境变量来实现状态的转换</li>
<li><code>ConcreteState</code>: 具体的状态类,每个状态类都有两个任务,一个是在自己状态下自己特有的行为,另一个是行为发生后，利用环境类改变环境类的状态.</li>
</ol>
<h3 id="我理解的状态模式"><a href="#我理解的状态模式" class="headerlink" title="我理解的状态模式"></a>我理解的状态模式</h3><p>我个人认为，状态模式是为了解决那些因为状态不同而行为不同，却使用条件语句来判断状态的问题，状态模式的重点是提取出那些随状态变化的方法，作为抽象类 。</p>
<h3 id="状态模式的优点"><a href="#状态模式的优点" class="headerlink" title="状态模式的优点"></a>状态模式的优点</h3><ol>
<li>结构清晰， 避免了使用大量的条件语句判断状态</li>
<li>将随状态变化的行为封装到一个类中，便于扩展</li>
<li>封装了状态转换的规则，封装性好</li>
</ol>
<h3 id="状态模式的缺点"><a href="#状态模式的缺点" class="headerlink" title="状态模式的缺点"></a>状态模式的缺点</h3><ol>
<li>可能会导致类的数量膨胀</li>
<li>实现结构较为复杂，看代码的时候，确实觉得比较难理解</li>
<li>增加一个类，可能会修改大量已有的类来添加转化规则。</li>
</ol>
<h3 id="状态模式的应用场景"><a href="#状态模式的应用场景" class="headerlink" title="状态模式的应用场景"></a>状态模式的应用场景</h3><ol>
<li>系统中有大量随状态变化而变化的方法</li>
<li>系统中存在大量重复的条件判断语句</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://book.douban.com/subject/26933281/" target="_blank" rel="external">图解设计模式</a><br><a href="https://book.douban.com/subject/4260618/" target="_blank" rel="external">设计模式之禅</a><br><a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/state.html" target="_blank" rel="external">图说设计模式-状态模式</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ninggee.github.io/2017/10/30/design-pattern-18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凝戈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/30/design-pattern-18/" itemprop="url">Pattern 18. Memento模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-30T00:14:48+08:00">
                2017-10-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式学习/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>Without violating encapsulation,capture and externalize an object’s internal state so that the object can be restored to this state later.</p>
</blockquote>
<p>备忘录模式：在不破坏封装的情况下，捕获一个对象的内部状态以至于对象可以在之后被恢复到这个状态。下面介绍一下备忘录模式是如何工作的。</p>
<h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>对于备忘录模式，我们可以看一下定义，在定义中，就已经介绍了备忘录模式是如何工作的了，其实备忘录就是通过储存某一时刻的内部状态，然后在之后，在通过这些状态恢复到那个时刻。说起来简单，但是还是有一些问题值得我们去探讨的。下面来看一段示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//发起人类</span></div><div class="line"><span class="comment">//发起人类是能够被回滚的类</span></div><div class="line"><span class="comment">//他可以创建快照，通过快照恢复到之间的状态</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String state;</div><div class="line"></div><div class="line">    <span class="function">String  <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(<span class="keyword">this</span>.getState());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreFromMemento</span><span class="params">(Memento memento)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.setState(memento.getState());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//备忘录类</span></div><div class="line"><span class="comment">//储存发起人类的状态</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String state;</div><div class="line"></div><div class="line">    Memento(String state)&#123;</div><div class="line">        <span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.state = state;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//备忘录管理员类</span></div><div class="line"><span class="comment">//负责管理，提供备忘录信息</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Memento memento;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.memento = memento;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> memento;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，我的代码只是简单的展示备忘录模式的概念和思想，可以看到，我们通过使用一个对象来保存一个对象的状态，通过记录必要的状态信息，我们就可以之后利用备忘录对象来恢复了。尽管我写的代码很简单，但是我们还是要注意到一些问题：</p>
<ol>
<li>关于可见性的问题:在备忘录模式的定义中，明确的说明了不破坏封装性，因此，为了做到这一点，我们将一些方法的可见性设置为包可见（就是不添加关键字），这样可以保证这些方法只能在同一个包内被使用，保证了信息不会被篡改。</li>
<li>关于caretaker类，可能有的人觉得这个类比较多余，但实际上，这个类必不可少，只是在我的示例中显得不那么重要，如果没有这个类，那么客户端程序就必须管理备忘录对象的产生和消亡，这是不对的，客户端很无辜，为什么要承担这样的责任，其次，如果我们想要有多个备份，如果没有caretaker类，我们就很难实现这个功能，但是有了这个类之后，我们就可以直接修改caretaker类了。</li>
</ol>
<p>下面是备忘录模式的图示：</p>
<p><img src="http://wx2.sinaimg.cn/mw690/e488f771ly1fkzkqyfoafj20q808ita7.jpg" alt="937FFE6C-0A6E-4045-A110-14FE5F7D35E4.png"></p>
<h3 id="备忘录模式中的角色"><a href="#备忘录模式中的角色" class="headerlink" title="备忘录模式中的角色"></a>备忘录模式中的角色</h3><ol>
<li><code>Originator</code>：发起者类，是要能够回滚的类，可以创建快照，通过快照恢复到之间的状态。</li>
<li><code>Memento</code>:备忘录类，储存发起者的状态，用于恢复发起者。</li>
<li><code>Caretaker</code>：备忘录管理类。负责管理备忘录对象。</li>
</ol>
<h3 id="备忘录模式的优点和缺点"><a href="#备忘录模式的优点和缺点" class="headerlink" title="备忘录模式的优点和缺点"></a>备忘录模式的优点和缺点</h3><p>由于备忘录模式有很多的变种，我们展示的只是标准的备忘录模式，很少会在项目中直接使用，因此，我们不总结他的优缺点了。</p>
<h3 id="备忘录模式的应用场景"><a href="#备忘录模式的应用场景" class="headerlink" title="备忘录模式的应用场景"></a>备忘录模式的应用场景</h3><ol>
<li>需要保存恢复数据的场景</li>
<li>需要提供回滚操作的场景（ctrl+z）</li>
</ol>
<h3 id="备忘录模式需要注意的事情"><a href="#备忘录模式需要注意的事情" class="headerlink" title="备忘录模式需要注意的事情"></a>备忘录模式需要注意的事情</h3><ol>
<li>何时删除备忘录对象，不用备忘录对象的时候，立刻删除。</li>
<li>备忘录的性能问题，不能太过频繁的创建备忘录对象。</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://book.douban.com/subject/26933281/" target="_blank" rel="external">图解设计模式</a><br><a href="https://book.douban.com/subject/4260618/" target="_blank" rel="external">设计模式之禅</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ninggee.github.io/2017/10/29/design-pattern-17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凝戈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/29/design-pattern-17/" itemprop="url">Pattern 17. Observer模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-29T20:10:40+08:00">
                2017-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式学习/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically.</p>
</blockquote>
<p>定义一个对象间的一对多的依赖关系以至于当一个对象的状态变化时，所有的依赖者都会被通知，并且自动的更新。观察者模式也被称为订阅-发布模式。</p>
<p>这个模式在平时用的还是比较多的，比如我们之前提到的MVC构架中的model和view之间就使用了观察者模式。下面介绍一下观察者模式是如何工作的。</p>
<h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>对于观察者模式，或者说是订阅-发布模式，我们可以想象生活中的收音机是如何工作的。首先是有一个被观察的对象，也就是一个广播频道，其次是有一个收音机，也就是一个观察者。只要广播频道有什么新的内容，收音机都可以收到，听众就可以听到它所收听频道的内容了。<br>在设计模式中的观察者模式基本也是这样的逻辑。下面我们还是先看一段示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//首先是subject也就是被观察者类</span></div><div class="line"><span class="comment">//被观察者应该可以动态的添加，删除观察它的观察者</span></div><div class="line"><span class="comment">//同时，当自己的状态发生变化的时候，可以通知观察他的观察者</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; observers = <span class="keyword">new</span> Vector&lt;Observer&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span> </span>&#123;</div><div class="line">        observers.add(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span> </span>&#123;</div><div class="line">        observers.remove(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(Observer observer: observers) &#123;</div><div class="line">            observer.update(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//具体的观察者</span></div><div class="line"><span class="comment">//在自己的状态发生变化的时候，通知所有观察者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subjectDo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.notifyObservers();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//观察者类</span></div><div class="line"><span class="comment">//抽象的观察者</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="comment">//观察者在观察到被观察者的变化时，可以对变化做出反应</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Subject subject)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//具体的观察者</span></div><div class="line"><span class="comment">//实现自己的对观察到的信息的处理逻辑</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Subject subject)</span> </span>&#123;</div><div class="line">        <span class="comment">// subject do something and observer recieve this message</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我的代码写的很简单，只是为了展示被观察者和观察者之间是如何通知的。<br>可以看到，被观察者可以动态的管理观察者，同时在自己的状态发生变化的时候更新观察者。因此把这几个功能单独提出来，作为观察者的抽象接口。<br>对于具体的被观察者，只要能在自己特定的时间通知观察者就可以了。<br>对于观察者，需要对观察对象的变化做出反应，每个观察者类的反应都不一样，因此update这个方法被设为抽象方法。<br>下面是观察者模式的图示：</p>
<p><img src="https://wx4.sinaimg.cn/mw690/e488f771gy1fkzdlh5kn0j20ns0c5dhu.jpg" alt="5CD75570-8FDB-4DD3-BB64-A2CBD01CF738.png"></p>
<h3 id="观察者模式中的角色"><a href="#观察者模式中的角色" class="headerlink" title="观察者模式中的角色"></a>观察者模式中的角色</h3><ol>
<li>subject：被观察者，可以动态的管理自己的观察者，同时在自己状态变化的时候，通知自己的观察者。</li>
<li>ConcreteSubject：具体的被观察者，实现自己的逻辑，在自己觉得恰当的时间通知观察者。</li>
<li>Observer：观察者类，观察者要在收到被观察者的通知之后，进行更新。</li>
<li>ConcreteObserver：具体的观察者，实现自己的更新逻辑。</li>
</ol>
<h3 id="我理解的观察者模式"><a href="#我理解的观察者模式" class="headerlink" title="我理解的观察者模式"></a>我理解的观察者模式</h3><p>观察者模式，我个人觉得不太恰当，还是订阅-发布模式比较恰当，将那种某一线程一直观察一个对象的模式，转变成被观察的对象变化了之后，主动通知观察者，提高了效率和性能。</p>
<h3 id="观察者模式的优点"><a href="#观察者模式的优点" class="headerlink" title="观察者模式的优点"></a>观察者模式的优点</h3><ol>
<li>观察者模式在观察者和被观察者之间建立了一种抽象耦合关系。</li>
<li>避免了一直观察一个对象的状态变化带来的性能开销</li>
</ol>
<h3 id="观察者模式的缺点"><a href="#观察者模式的缺点" class="headerlink" title="观察者模式的缺点"></a>观察者模式的缺点</h3><ol>
<li>当一个被观察者有多个观察者的时候，在开发和调试的时候会比较麻烦，通知的过程会变得很长，影响性能。</li>
<li>当一个观察者观察多个对象的时候，可能会对某个函数返回特别慢，影响整体的性能。解决方式是异步。</li>
</ol>
<h3 id="观察者模式的应用场景"><a href="#观察者模式的应用场景" class="headerlink" title="观察者模式的应用场景"></a>观察者模式的应用场景</h3><ol>
<li>一个对象变化，会影响多个对象的状态，同时不知道有哪些对象会变化的时候。</li>
<li>编程中的一对多的情况，基本都可以利用观察者模式。</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://book.douban.com/subject/26933281/" target="_blank" rel="external">图解设计模式</a><br><a href="https://book.douban.com/subject/4260618/" target="_blank" rel="external">设计模式之禅</a><br><a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html" target="_blank" rel="external">图说设计模式-观察者模式</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ninggee.github.io/2017/10/29/design-pattern-16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凝戈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/29/design-pattern-16/" itemprop="url">Pattern 16. Mediator模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-29T12:05:05+08:00">
                2017-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式学习/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>Define an object that encapsulates how a set of objects interact.Mediator promotes loose coupling by keeping objects from referring to each other explicitly,and it lets you vary their interaction independently.</p>
</blockquote>
<p>定义一个对象来封装一系列对象如何交互。中介者使对象之间不直接相互引用来减少耦合，同时使你可以独立的变化他们。中介者模式也被称为调停者模式。</p>
<p>中介者模式主要是用来将系统中紧密相互耦合的对象形成的网状结构转变为星型结构，减少了对象之间的相互耦合关系。下面我们来看中介者模式是如何工作的。</p>
<h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>对于相互紧密耦合的各个对象，通过提供一个中介者，来去除对象之间的紧密耦合，具体来说就是，原有的每个对象都存一个中介者，同时中介者也都保存各个对象，一个对象想要调用别的对象的方法，不是直接访问另一个对象，而是通过中介者，来达到对其他对象的依赖。下面还是进入我们熟悉的代码环节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//中介者类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</div><div class="line">    <span class="comment">//保存所有的colleague</span></div><div class="line">    <span class="keyword">protected</span> ConcreteColleague1 colleague1;</div><div class="line">    <span class="keyword">protected</span> ConcreteColleague2 colleague2;</div><div class="line"></div><div class="line">    <span class="comment">//通过get/setter来引入依赖</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ConcreteColleague1 <span class="title">getColleague1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> colleague1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleague1</span><span class="params">(ConcreteColleague1 colleague1)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.colleague1 = colleague1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ConcreteColleague2 <span class="title">getColleague2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> colleague2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleague2</span><span class="params">(ConcreteColleague2 colleague2)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.colleague2 = colleague2;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//中介者类的业务逻辑</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">mediatorDo1</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">mediatorDo2</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//具体的中介者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteMediator</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//这里只是简化的对colleague类的方法调用</span></div><div class="line">    <span class="comment">//但实际上中介者类中还是有一些很关键的逻辑的</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mediatorDo1</span><span class="params">()</span> </span>&#123;</div><div class="line">        getColleague1().selfDo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mediatorDo2</span><span class="params">()</span> </span>&#123;</div><div class="line">        getColleague2().selfDo();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//colleague类</span></div><div class="line"><span class="comment">//提取出colleague的共同点，生成抽象类</span></div><div class="line"><span class="comment">//colleague都要保存一个中介者，来实现对别的对象的访问</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> Mediator mediator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mediator = mediator;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//具体的colleague类</span></div><div class="line"><span class="comment">//这里实现的比较简单，就是实现自己的业务逻辑，同时通过中介者调用别的对象的方法。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague1</span><span class="params">(Mediator mediator)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(mediator);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfDo</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">othersDo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mediator.mediatorDo2();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague2</span><span class="params">(Mediator mediator)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(mediator);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfDo</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">othersDo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mediator.mediatorDo1();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是中介者模式的图示：</p>
<p><img src="https://wx3.sinaimg.cn/mw690/e488f771ly1fkyzjxjsjej20pm0hw0up.jpg" alt="CC8C17F5-3858-48AE-A454-ADD6E089F034.png"></p>
<h3 id="中介者模式中的角色"><a href="#中介者模式中的角色" class="headerlink" title="中介者模式中的角色"></a>中介者模式中的角色</h3><ol>
<li>mediator:抽象的中介者，定义了统一的接口，用于同事类之间的通信。</li>
<li>ConcreteMediator：具体的中介者，实现了抽象中介者的方法。</li>
<li>Colleague： 同事类，每个同事类都知道中介者，而且通过中介者与其他角色通信，一般同事类既有自己的方法也有依赖别的同事的方法。</li>
</ol>
<h3 id="中介者模式的优点"><a href="#中介者模式的优点" class="headerlink" title="中介者模式的优点"></a>中介者模式的优点</h3><ol>
<li>减少了依赖，同事之间的交错的依赖全部转为对中介者的依赖，减少了依赖的数量。</li>
<li>降低了耦合。</li>
<li>可以简化各个同事类的实现</li>
</ol>
<h3 id="中介者模式的缺点"><a href="#中介者模式的缺点" class="headerlink" title="中介者模式的缺点"></a>中介者模式的缺点</h3><p>由于中介者角色包含了各个同事之间的交互逻辑，当同事类增多的时候，会变得非常臃肿，难以修改。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>系统中对象相互依赖，难以理解。</li>
<li>一个对象引用了大量其他对象导致难以复用。</li>
<li>一些交互的公共行为，希望把处理逻辑集中处理时。</li>
</ol>
<h3 id="中介者模式的实例"><a href="#中介者模式的实例" class="headerlink" title="中介者模式的实例"></a>中介者模式的实例</h3><ol>
<li>MVC构架中的controller角色就运用到了中介者模式。</li>
<li>GUI开发时，一个界面组件的复杂交互，可以把交互写到中介者中，避免处理逻辑分散到各个组件类中。</li>
<li>MSN服务，可以利用中介者模式作为中心服务器转发聊天信息，如果没有中介者，信息就会广播到所有人的客户端，只有目标客户端才会读取信息。</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://book.douban.com/subject/26933281/" target="_blank" rel="external">图解设计模式</a><br><a href="https://book.douban.com/subject/4260618/" target="_blank" rel="external">设计模式之禅</a><br><a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/mediator.html" target="_blank" rel="external">图说设计模式-中介者模式</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ninggee.github.io/2017/10/28/design-pattern-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凝戈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/design-pattern-15/" itemprop="url">Pattern 15.  Facade模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-28T23:47:23+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式学习/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>Provide a unified interface to a set of interfaces in a subsystem.Facade defines a higher-level interface that makes the subsystem easier to use.</p>
</blockquote>
<p>为子系统的一系列接口提供一个统一的接口。门面模式定义了一个更高层的接口使子系统更容易使用。</p>
<p>门面模式又被称为外观模式，是一种对象结构型模式。</p>
<h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>门面模式的工作原理其实很简单。就是为子系统的多个接口提供一个更高层的接口，把对子系统的调用都限制外观模式的这个类里面。避免客户端对子系统耦合太过严重。</p>
<p>虽然这个模式说起来很简单，也很好理解，但是实例代码写起来还是比较难写的。下面我就模仿设计模式之禅中通用代码来展示一下门面模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//子系统类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystem1</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//子系统1实现自己的功能</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystem2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//子系统2实现自己的功能</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystem3</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//子系统3实现自己的功能</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//门面类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapDo</span><span class="params">()</span> </span>&#123;</div><div class="line">        SubSystem1 s1 = <span class="keyword">new</span> SubSystem1();</div><div class="line">        SubSystem2 s2 = <span class="keyword">new</span> SubSystem2();</div><div class="line">        SubSystem3 s3 = <span class="keyword">new</span> SubSystem3();</div><div class="line"></div><div class="line">        s1.doSomething();;</div><div class="line">        s2.doSomething();</div><div class="line">        s3.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，门面模式主要就是封装了子系统的调用到门面类。客户端无需知道子系统的复杂使用方法，只需要简单的调用门面模式提供的接口就可以了。<br>下面是门面模式的图示：</p>
<p><img src="https://wx1.sinaimg.cn/mw690/e488f771ly1fkye84v1fvj21au0w20yf.jpg" alt="87E357BF-8B5F-4A7C-B077-6B92B940AA42.png"></p>
<h3 id="门面模式中的角色"><a href="#门面模式中的角色" class="headerlink" title="门面模式中的角色"></a>门面模式中的角色</h3><ol>
<li>Facade：客户端通过门面类来使用子系统的功能，门面类一般对子系统有全面的了解。</li>
<li>子系统类：这个没什么好说的。一个系统可以有多个子系统，子系统对门面并不之情对于子系统来说，门面类只是他的一个使用者罢了。</li>
</ol>
<h3 id="我理解的门面模式"><a href="#我理解的门面模式" class="headerlink" title="我理解的门面模式"></a>我理解的门面模式</h3><p>我理解的门面模式就是屏蔽了客户端对子系统的复杂耦合。对于客户端时候能直接对子系统进行调用，设计模式之禅和图说设计模式两本书有不同的看法。</p>
<ul>
<li>设计模式之禅认为，门面类是外界访问子系统的唯一通道上，客户端不能直接对子系统进行访问，必须通过门面类。</li>
<li>但是图说设计模式认为，不应该禁止客户端对子系统的访问，如果限制只能通过门面类访问子系统，就会使这个系统不够灵活。</li>
</ul>
<p>我觉得还是看业务需求吧，我个人倾向于禁止客户端直接访问子系统，不然门面存在的意义不是很小了吗。<br>我想的是抽象门面类形成接口，根据需求生成不同的门面类。</p>
<h3 id="门面模式的优点"><a href="#门面模式的优点" class="headerlink" title="门面模式的优点"></a>门面模式的优点</h3><ol>
<li>减少了系统之间的相互依赖，可以看到原来的客户端依赖子系统的各个类，变成只依赖门面，减少了大量的耦合关系</li>
<li>提高了灵活性。依赖少了，自然变化的包袱就小了。子系统怎么变都可以，只需要改改门面内部的逻辑就可以了。</li>
<li>提高了安全性，客户端只能访问门面提供了对子系统有限的访问。</li>
</ol>
<h3 id="门面模式的缺点"><a href="#门面模式的缺点" class="headerlink" title="门面模式的缺点"></a>门面模式的缺点</h3><ol>
<li>不符合开闭原则，子系统的修改会直接修改门面类的代码。</li>
</ol>
<h3 id="门面模式的应用场景"><a href="#门面模式的应用场景" class="headerlink" title="门面模式的应用场景"></a>门面模式的应用场景</h3><ol>
<li>为复杂的子系统提供简单的使用接口时。</li>
<li>客户端与子系统存在大量的复杂的耦合，通过门面类来解耦。</li>
<li>可以在多层结构中每层定义一个门面类，减少层与层之前的耦合<del>突然想起OSI七层结构</del></li>
</ol>
<h3 id="门面模式的扩展"><a href="#门面模式的扩展" class="headerlink" title="门面模式的扩展"></a>门面模式的扩展</h3><ol>
<li>一个子系统可以有多个外观类</li>
<li>外观类可以抽象出抽象的父类，便于扩展</li>
</ol>
<h3 id="门面模式的注意点"><a href="#门面模式的注意点" class="headerlink" title="门面模式的注意点"></a>门面模式的注意点</h3><p>不要把子系统的逻辑引入门面类，也可以说不要通过门面类来增加子系统的功能，门面类的职责很简单，就是去掉客户端对子系统的耦合关系，使客户端对子系统的调用更加简单。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://book.douban.com/subject/26933281/" target="_blank" rel="external">图解设计模式</a><br><a href="https://book.douban.com/subject/4260618/" target="_blank" rel="external">设计模式之禅</a><br><a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/facade.html" target="_blank" rel="external">图说设计模式-外观模式</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ninggee.github.io/2017/10/28/design-pattern-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凝戈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/design-pattern-14/" itemprop="url">Pattern 14. Chain of Responsibility模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-28T22:11:22+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式学习/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.Chain the receiving objects and pass the request along the chain until an object handles it.</p>
</blockquote>
<p>通过使用超过一个对象机会来处理请求来避免请求的发送者和接受者耦合。把接收对象串起来成链，沿着这条链传递请求直到一个对象处理它。</p>
<p>正如这个模式的名字–责任链模式说的那样，整个模式最后形成了一个处理请求的链。这也就暗示着责任链模式最重要的一点就是那个链。下面我们来看一下这个模式是如何工作的。</p>
<h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>责任链模式，重点是形成那个链。我们很自然的就想到了我们学习过的数据结构–链表。链表是如何做的呢？链表除了储存了自己的信息之外，还储存了自己的后继的信息。这也正是责任链模式所采用的方法。下面我们来看代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//请求类</span></div><div class="line"><span class="comment">//在这个模式里，请求都没有出现在类图里，就不实现了，</span></div><div class="line"><span class="comment">//用一个空类来占位</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//处理者类</span></div><div class="line"><span class="comment">//抽象的处理者</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="comment">//保存后继元素来形成责任链</span></div><div class="line">    <span class="keyword">private</span> Handler successor;</div><div class="line">    </div><div class="line">    <span class="comment">//父类中定义一个接收处理者的构造函数</span></div><div class="line">    <span class="comment">//来保证子类一定有这个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Handler handler)</span> </span>&#123;</div><div class="line">        successor = handler;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//判断当前的处理者能否处理当前请求</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">canHandle</span><span class="params">(Request request)</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">//处理请求的代码</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Request request)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">//获取后继元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getSuccessor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> successor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//算是用到了模板方法模式吧</span></div><div class="line">    <span class="comment">//可以加上final关键字来阻止子类修改</span></div><div class="line">    <span class="comment">//判断当前的类能不能处理</span></div><div class="line">    <span class="comment">//能就处理，不能就交给下一个处理者处理</span></div><div class="line">    <span class="comment">//如果最后也没有元素来处理，就抛出异常或者用其他办法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(canHandle(request)) &#123;</div><div class="line">            handle(request);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(getSuccessor() != <span class="keyword">null</span>) &#123;</div><div class="line">                getSuccessor().handleRequest(request);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//没有处理者了，是抛出异常还是忽略都可以</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//具体的处理者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteHandler</span><span class="params">(Handler handler)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(handler);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">canHandle</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">        <span class="comment">//处理请求的方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，责任链模式的主要思想就是通过类似链表的形式形成责任链，如果一个处理者可以处理，那么就在这里处理，如果不可以就传给下一个元素，这样的话，就避免了请求者和处理者解耦，也不需要一个角色来分配请求给对应的处理者。</p>
<p>下面是责任链模式的图示：</p>
<p><img src="https://wx1.sinaimg.cn/mw690/e488f771ly1fkybl5mnrcj21e00u4n29.jpg" alt="AEE2A4CC-A841-46DD-8CDF-6B5DFFC33410.png"></p>
<h3 id="责任链模式中的角色"><a href="#责任链模式中的角色" class="headerlink" title="责任链模式中的角色"></a>责任链模式中的角色</h3><ol>
<li>Handler:处理者定义了处理请求的接口，实现了责任链模式的基本逻辑，每个处理者保存自己的后继者，如果自己能处理请求就自己处理，不能处理就传给下一给处理者。</li>
<li>ConcreteHandler：具体的处理者。实现了各自的处理函数。</li>
<li>Client:客户端负责生成责任链，将请求发给第一个处理者。</li>
</ol>
<h3 id="我理解的责任链模式"><a href="#我理解的责任链模式" class="headerlink" title="我理解的责任链模式"></a>我理解的责任链模式</h3><p>我觉得责任链模式主要的意义在于解耦，解耦了请求和请求的处理者。同时也不需要一个分发请求的角色。<br>而责任链模式的重点在于链，形成了一个链。这样就不用考虑到底谁能处理请求，处理不了就一直往下传递就可以了。</p>
<h3 id="责任链模式的优点"><a href="#责任链模式的优点" class="headerlink" title="责任链模式的优点"></a>责任链模式的优点</h3><p>优点就是解耦了请求和请求的处理者。</p>
<h3 id="责任链模式的缺点"><a href="#责任链模式的缺点" class="headerlink" title="责任链模式的缺点"></a>责任链模式的缺点</h3><ol>
<li>debug困难。当责任链成形之后，在某一环节出错，找到到底是哪一个环节出错是很困难得。</li>
<li>当责任链特别长的时候，会造成形成的问题。每个请去要很久才会有回复。</li>
</ol>
<h3 id="责任链模式的应用场景"><a href="#责任链模式的应用场景" class="headerlink" title="责任链模式的应用场景"></a>责任链模式的应用场景</h3><p>我个人觉得处理请求这类的情况都可以用责任链模式。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://book.douban.com/subject/26933281/" target="_blank" rel="external">图解设计模式</a><br><a href="https://book.douban.com/subject/4260618/" target="_blank" rel="external">设计模式之禅</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ninggee.github.io/2017/10/28/design-pattern-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凝戈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/design-pattern-13/" itemprop="url">Pattern 13. Visitor模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-28T17:39:32+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式学习/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.</p>
</blockquote>
<p>访问者表示了对对象数据结构中的元素的操作。访问者让你可以不必需要要操作的元素就可以定义新的操作。</p>
<p>从定义中我们可以看到，访问者模式涉及的三个角色。分别是数据结构，元素和访问者。访问者模式模式实际上是一种任务集中化的思想。下面来看一下访问者模式是如何工作的。</p>
<h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>对于访问者模式如何工作，我们不妨先想象一下，假如我们需要对数据结构中的对象进行某种操作，一般的话，我们会在元素类定义这种操作，这样我们在使用这个元素时，直接调用这个函数就好了。OK，我们算是解决了这个问题。<br>假如，我们需要这个元素有一个新的操作，怎么办？<br>Ok，我们还是可以通过添加元素的函数来提供这样的操作？<br>那么假如有很多的操作需要添加呢？那么在元素类中继续添加方法就显得很不恰当，尤其是这个数据结构中的元素可能是一个父类的不同子类，他们的操作的实现方法还不同。<br>为了解决这个问题，我们的访问者模式出现了，它是通过使元素类接收一个访问者类，调用访问者的方法来实现各种操作的，当增加新的操作时，增加访问者类就好了，不需要对元素有任何的修改。这也正是访问者模式定义所提到的。下面我们还是看一段代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//访问者类</span></div><div class="line"><span class="comment">//抽象的访问者</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Visitor &#123;</div><div class="line">    <span class="comment">//访问方法</span></div><div class="line">    <span class="comment">//通过函数重载的方法</span></div><div class="line">    <span class="comment">//来对每种元素提供不同的访问方法</span></div><div class="line">    </div><div class="line">    <span class="comment">//访问者定义了可以访问哪些元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement1  element)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement2  element)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//具体的访问者类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitor</span> <span class="keyword">extends</span> <span class="title">Visitor</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement1 element1)</span> </span>&#123;</div><div class="line">        element1.elementDo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElement2 element2)</span> </span>&#123;</div><div class="line">        element2.elementDo();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//元素类</span></div><div class="line"><span class="comment">//抽象的元素类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">elementDo</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">//元素类声明了可以接收哪类访问者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElement1</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">elementDo</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Concrete element1 do"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//accept方法基本上已经形成了定式了</span></div><div class="line">    <span class="comment">//几乎所有的实现都是这样的</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</div><div class="line">        visitor.visit(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElement2</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">elementDo</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Concrete element2 do"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</div><div class="line">        visitor.visit(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不知道看上面的代码大家是不是觉得很过瘾？</p>
<p>可以看到，虽然访问者模式理解起来时很简单的，但是具体实现起来还是有一点绕的。<br>尤其是元素类接收访问者，调用访问者的<code>visit</code>方法，而访问者反过来又去调用元素类自身的方法。</p>
<p>下面是访问者模式的图示：</p>
<p><img src="https://wx1.sinaimg.cn/mw690/e488f771gy1fky3mon5v2j20qw08wac3.jpg" alt="A8E883BC-5A1E-482D-81BE-41A6CFAC128D.png"></p>
<h3 id="访问者模式中的角色"><a href="#访问者模式中的角色" class="headerlink" title="访问者模式中的角色"></a>访问者模式中的角色</h3><ol>
<li><code>Visitor</code>: 抽象的访问者。声明了访问者可以访问哪些元素。也就是<code>visit</code>函数的参数定义了哪些元素可以访问。</li>
<li><code>ConcreteVisitor</code>：具体的访问者。实现了<code>visit</code>方法，也就是具体实现了某种操作。</li>
<li><code>Element</code>：抽象的元素类。声明了元素类可以接受哪类访问者的访问。</li>
<li><code>ConcreteElement</code>：具体的元素类，定义了<code>accept</code>方法，基本上<code>accept</code>方法都是直接调用访问者的visit方法。</li>
<li><code>ObjectStructure</code>：结构对象，一般是元素类的生产者，比如<code>JAVA</code>中的<code>Collection</code>类。</li>
</ol>
<h3 id="我理解的访问者模式"><a href="#我理解的访问者模式" class="headerlink" title="我理解的访问者模式"></a>我理解的访问者模式</h3><p>我个人认为访问者模式就是将一些对对象的操作从对象本身提取出来，每种操作作为一种访问类，使访问任务集中化，增加访问操作直接加访问者类就好了。<br>其实这也就是我在如何工作一节中所解释的那样。</p>
<h3 id="访问者模式的优点"><a href="#访问者模式的优点" class="headerlink" title="访问者模式的优点"></a>访问者模式的优点</h3><ol>
<li>扩展性好：添加操作只需要加访问者。不需要对元素进行什么改动。</li>
<li>灵活性高。想进行某些麻烦的操作，不需要改元素类，直接在访问者中进行操作就好。</li>
<li>责任明确：元素类只负责储存信息和一些相关的操作。具体如何使用组织这些数据由访问者来决定。</li>
</ol>
<h3 id="访问者模式的缺点"><a href="#访问者模式的缺点" class="headerlink" title="访问者模式的缺点"></a>访问者模式的缺点</h3><ol>
<li>访问者必须知道所有的具体元素。</li>
<li>一旦增加了新的元素类，访问者类修改起来非常的麻烦。</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>一个对象结构包含很多的对象。这些对象各不相同，而你想对这些对象进行某种操作的时候。</li>
<li>需要对一些对象进行多种不同的操作，不想在元素中定义这些操作方法的时候。</li>
</ol>
<h3 id="访问者模式和迭代器模式"><a href="#访问者模式和迭代器模式" class="headerlink" title="访问者模式和迭代器模式"></a>访问者模式和迭代器模式</h3><ol>
<li>迭代器模式：它是将所有的元素看成是父类，统一的进行处理所有的元素（包含子类元素）这要求各个子类有相同的结构和表现。</li>
<li>访问者模式：访问者模式知道元素类的每个子类，并对每个子类都有一个不同的方法来进行访问。这更多是对迭代器模式无法处理的情况进行处理。</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://book.douban.com/subject/26933281/" target="_blank" rel="external">图解设计模式</a><br><a href="https://book.douban.com/subject/4260618/" target="_blank" rel="external">设计模式之禅</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ninggee.github.io/2017/10/28/design-pattern-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凝戈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/design-pattern-12/" itemprop="url">Pattern 12. Composite模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-28T11:37:47+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式学习/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>Compose objects into tree structures to represent part-whole hierarchies.Composite lets clients treat individual objects and compositions of objects uniformly</p>
</blockquote>
<p>将对象组织成树形结构来表示<strong>部分-整体</strong>的层次关系。组合使客户端统一的看待单个对象和组合对象。</p>
<p>组合模式又称合成模式，有时也被称为<strong>部分-整体</strong>模式，描述了部分与整体的关系。</p>
<p>可以说，凡是形成了树形结构的对象（们），都可以利用组合模式。下面来看一下组合模式是如何工作的。</p>
<h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>根据定义，组合模式首先要把对象们组织成树形结构，然后要使客户端能将一致的看待个体和整体。那么很显然，方法就是将部分和整体提取出一个父类，使他们都继承自一个父类，这样就可以把他们看成是父类的对象。同时，使组合对象能嵌套的包含个体对象和组合对象，这样就可以形成树形结构了。下面看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//组件类</span></div><div class="line"><span class="comment">//个体和整体的统一的父类</span></div><div class="line"><span class="comment">//一般为抽象类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//部分与整体都有的行为</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">commonDo</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">//------------------------</span></div><div class="line">    <span class="comment">//整体特有的行为</span></div><div class="line">    </div><div class="line">    <span class="comment">//添加部分到整体</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">//从整体移除部分</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">//从整体中提取全部的子</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Component&gt; <span class="title">getChild</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//部分类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="comment">//部分与整体都有的行为</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commonDo</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"common do"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//------------------------</span></div><div class="line">    <span class="comment">//整体特有的行为</span></div><div class="line">    </div><div class="line">    <span class="comment">//添加部分到整体</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"unsupport operation"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//从整体移除部分</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"unsupport operation"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//从整体中提取全部的子</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Component&gt; <span class="title">getChild</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"unsupport operation"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//整体类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> List&lt;Component&gt; composite = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="comment">//部分与整体都有的行为</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commonDo</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"common do"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//------------------------</span></div><div class="line">    <span class="comment">//整体特有的行为</span></div><div class="line">    </div><div class="line">    <span class="comment">//添加部分到整体</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        composite.add(component);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//从整体移除部分</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">       <span class="comment">//remove from list</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//从整体中提取全部的子</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Component&gt; <span class="title">getChild</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> composite;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整体上代码并不复杂，需要注意的一点是，关于整体特有的方法是方法父类，还是下放到子类的问题。<br>如果放到父类的话，那么在子类中，个体类要么直接报错，要么什么都不做，或者不实现。<br>如果是只放到整体类中，那就需要在使用的过程中进行判断，同时进行类型的转换，来使用整体特有的方法。</p>
<p>到底使用哪种方法，就看个人的喜好了。</p>
<p>下面来看组合模式的图示：</p>
<p><img src="http://wx4.sinaimg.cn/mw690/e488f771ly1fkxt4oagbmj21ew0ygteq.jpg" alt="D59FCC72-BB5A-46B0-921A-29D4600DF349.png"></p>
<h3 id="组合模式中的角色"><a href="#组合模式中的角色" class="headerlink" title="组合模式中的角色"></a>组合模式中的角色</h3><ol>
<li><code>component</code>： 组件类，是整体和个体的父类，使整体和个体可以被看成一个整体。同时定义了一些通用的方法。</li>
<li><code>Leaf</code>：叶子节点类，是部分类。</li>
<li><code>Composite</code>:整体类，包含叶子节点和嵌套的包含整体节点</li>
</ol>
<h3 id="我理解的组合模式"><a href="#我理解的组合模式" class="headerlink" title="我理解的组合模式"></a>我理解的组合模式</h3><p>对于组合模式来说，我觉得图解设计模式这本书中的例子很形象：<br>对于文件夹和文件的例子，如果不使用组合模式，而是将文件夹和文件看成两个独立的类，二者之间没有什么关联，我们可以想象，如果要写一个程序来往文件夹添加文件和文件夹，然后遍历一个文件夹，计算文件夹的大小会有多么的麻烦。</p>
<p>但是使用了组合模式整个代码就会变得很整洁，也很好写。</p>
<p>因此组合模式，是对树形结构的一种利用，抽象出共同点，形成抽象父类，便于统一管理</p>
<h3 id="组合模式的优点"><a href="#组合模式的优点" class="headerlink" title="组合模式的优点"></a>组合模式的优点</h3><ol>
<li>客户端调用简单，对于客户端来说，可以一致的把叶子节点和整体节点看成组件类，使用简单</li>
<li>节点可以自由的添加，无论是想在一个整体节点里添加叶子节点还要整体节点都是十分简单的事情。</li>
</ol>
<h3 id="组合模式的缺点"><a href="#组合模式的缺点" class="headerlink" title="组合模式的缺点"></a>组合模式的缺点</h3><p>我暂时还没想到^_^</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>维护部分和整体关系时，或者对象间可以形成树形结构时。</li>
<li>从整体可以独立出部分模块的时候。</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://book.douban.com/subject/26933281/" target="_blank" rel="external">图解设计模式</a><br><a href="https://book.douban.com/subject/4260618/" target="_blank" rel="external">设计模式之禅</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ninggee.github.io/2017/10/27/design-pattern-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凝戈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/27/design-pattern-11/" itemprop="url">Pattern 11.  Strategy模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-27T23:51:00+08:00">
                2017-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式学习/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>Define a family of algorithms,encapsulate each one,and make them interchangeable.</p>
</blockquote>
<p>定义一组算法，封装他们，同时使他们可以相互替换</p>
<p>策略模式听起来比较高大上，但是实际上来说，是一个比较简单的模式。可以说就是对封装和多态的综合应用。下面来看策略模式是如何工作的。</p>
<h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>根据策略模式的定义我们可以看出，策略模式的重点是封装和可替换，我们就可以肯直接的想到抽象出一个通用的接口，来面向接口进行编程，这样就实现了可替换，如果还有一些数据需要封装，那就用抽象类来封装。这也正式策略模式所使用的方法。</p>
<p>但是策略模式还是有一点需要注意的，那就是在策略模式中有一个<code>Context</code>角色，这个角色用来隔离客户端对具体策略的访问，同时封装了可能的变化。说了这么多，感觉都有点晕了，还是看一段代码比较直接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//抽象策略类</span></div><div class="line"><span class="comment">//如果只有方法的话，也可以用接口</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">starategyDo</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//具体的策略类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategy1</span> <span class="keyword">extends</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyDo</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"strategy1 do"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategy2</span> <span class="keyword">extends</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyDo</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"strategy2 do"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//context类</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</div><div class="line">    <span class="comment">//储存strategy对象</span></div><div class="line">    <span class="comment">//对象不同，策略不同</span></div><div class="line">    <span class="keyword">private</span> Strategy __strategy;</div><div class="line">    </div><div class="line">    <span class="comment">//可以动态设置要使用的策略</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</div><div class="line">        __strategy = strategy;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//context对外提供的功能</span></div><div class="line">    <span class="comment">//一般来说和strategy提供的接口不同</span></div><div class="line">    <span class="comment">//不然就是代理了</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDo</span><span class="params">()</span> </span>&#123;</div><div class="line">        __strategy.strategyDo();</div><div class="line">        System.out.println(<span class="string">"context do"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，整个策略模式的表示代码是比较简单的，策略模式也确实是一个比较简单的模式。<br>面向对象编程的重点就是抽象和封装，提取共同点作为抽象父类（接口），在子类中各自体现自己的不同。对于一项工作又不同的方法去解决他，那么共同点就是解决这个问题，不同就是方法不同，我们可以看到，策略类就是这样。<br>关于<code>context</code>类，这个类比较有意思，它将策略和客户端代码隔离，这样客户端不关心具体用的什么策略，只要问题解决就可以了，同时，在解决客户端的需求时，可能只有一部分是有多种策略的，这样，其他部分可以放到 <code>context</code>类中，这样也算是将变化封装在这个类中。<br>下面是策略模式的图示：</p>
<p><img src="http://wx2.sinaimg.cn/mw690/e488f771ly1fkx8yav1r9j20p00e6gnt.jpg" alt="D41D3DFA-6452-4AF6-BA53-B08FDADEB87D.png"></p>
<h3 id="策略模式中的角色"><a href="#策略模式中的角色" class="headerlink" title="策略模式中的角色"></a>策略模式中的角色</h3><ol>
<li><code>strategy</code>: 策略和算法的抽象类或者接口，定义了算法提供的功能。</li>
<li><code>ConcreteStrategy</code>: 具体的策略类，实现了<code>strategy</code>定义的接口</li>
<li><code>context</code>:隔离了客户端与策略族，也可以封装一些可能的变化</li>
</ol>
<h3 id="我理解的策略模式"><a href="#我理解的策略模式" class="headerlink" title="我理解的策略模式"></a>我理解的策略模式</h3><p>策略模式整体来说是个比较简单的模式，看来是策略类比价重要，但是在我看来，<code>context</code>类才是这个模式的灵魂。<br>对于策略类来说，只是抽象了公共的接口，同时使用继承和多态的特性实现了策略的替换，这个对于有多种可能的策略，我们是横容易想到使用抽象和继承等方式来实现的。<br>但是对于<code>context</code>类，它是一个比较重要的类，</p>
<ul>
<li>一方面它隔离了客户端与策略类，这要求它了解有哪些策略类，同时了解客户端所需要的功能</li>
<li>另一方面，当有一些变化的时候，比如除了策略类提供的接口还需要一些其他的操作才能完成最终的需求的时候，就需要在<code>context</code>类中进行一些操作了</li>
</ul>
<p>因此在策略模式中，<code>context</code>类是最为关键的</p>
<h3 id="策略模式的优点"><a href="#策略模式的优点" class="headerlink" title="策略模式的优点"></a>策略模式的优点</h3><ol>
<li>可以灵活的切换算法，而不需要修改原有系统</li>
<li>扩展性好，添加一个策略不会对原有的系统带来什么修改</li>
<li>可以避免使用多种条件判断，减少了系统的复杂性</li>
</ol>
<h3 id="策略模式的缺点"><a href="#策略模式的缺点" class="headerlink" title="策略模式的缺点"></a>策略模式的缺点</h3><ol>
<li><code>context</code>类必须知道所有的策略类，违背迪米亚特法则</li>
<li>会产生很多的策略类，增加了类的数量</li>
</ol>
<h3 id="策略模式的使用场景"><a href="#策略模式的使用场景" class="headerlink" title="策略模式的使用场景"></a>策略模式的使用场景</h3><ol>
<li>多个对象只是在行为上有不同，可以使用策略模式动态的选择哪个行为</li>
<li>程序要在多个算法之间切换</li>
<li>不希望暴露算法细节，可以使用策略类封装算法</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://book.douban.com/subject/26933281/" target="_blank" rel="external">图解设计模式</a><br><a href="https://book.douban.com/subject/4260618/" target="_blank" rel="external">设计模式之禅</a><br><a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/strategy.html" target="_blank" rel="external">图说设计模式-策略模式</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ninggee.github.io/2017/10/24/design-pattern-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningge">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凝戈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/24/design-pattern-10/" itemprop="url">Pattern 10. Decorate模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-24T23:49:15+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式学习/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>Attach additional responsibilities to an object dynamically keeping the same interface. Decorators provide a flexible alternative to subclassing for extending functionality.</p>
</blockquote>
<p>动态的给一个对象添加功能同时保持接口不变。装饰器提供了相比于子类更灵活的扩展功能的方法。</p>
<p>装饰模式也被称为包装器（Wrapper),装饰模式有时候也被称为“油漆工模式”</p>
<h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>装饰模式重点是保证接口的不变，这样在客户端没有感知的情况下，可以动态的为对象添加功能。下面来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//抽象的组件类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//具体的组件类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"component call method1"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//抽象的装饰类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span></span>&#123;</div><div class="line">    <span class="keyword">protected</span> Component __component;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.__component = component;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//具体的装饰类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecrator</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(component);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"decorator call method1"</span>);</div><div class="line">        </div><div class="line">        __component.method1();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，上面的<code>Decorator</code>类，保存了<code>Component</code>的对象实例，这样保证了，<code>Decorator</code>可以实现<code>Component</code>已经提供(实现)的功能（通过<strong>代理</strong>的手段），同时，<code>Decorator</code>保持和<code>Component</code>的接口一致，这样，客户端可以直接调用经过<code>Decorator</code>装饰过的对象，而不需要修改逻辑。<br>下面是装饰模式的图示：</p>
<p><img src="http://wx3.sinaimg.cn/mw690/e488f771ly1fktruc0om4j20p00lytbb.jpg" alt="B63F40D6-E443-4957-B937-6C72E060499B.png"></p>
<h3 id="装饰模式中的角色"><a href="#装饰模式中的角色" class="headerlink" title="装饰模式中的角色"></a>装饰模式中的角色</h3><ol>
<li>component: component是这个模式中的核心组件，一般为抽象类或者接口，定义了这个模式中对外开放的接口，也就是装饰器和一般对象拥有的相同的接口</li>
<li>ConcreteComponent: ConcreteComponent是component的实现类，实现了component定义的功能。</li>
<li>Decorator: Decorator一般为抽象类，存储了component对象，这也就是Decorator知道他要装饰的对象， 同时它也提供了和component类相同的接口</li>
<li>ConcreteDecorator: 就是decrator的实现类</li>
</ol>
<h3 id="我理解的装饰模式"><a href="#我理解的装饰模式" class="headerlink" title="我理解的装饰模式"></a>我理解的装饰模式</h3><p>还是在读<a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/decorator.html" target="_blank" rel="external">图说设计模式之装饰模式</a>一节有感，书中说：</p>
<blockquote>
<p>一般有两种方式可以实现给一个类或对象增加行为：</p>
<ul>
<li>继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li>
<li>关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)</li>
</ul>
</blockquote>
<p>实际上，装饰器模式对应了现实中的一种需求，想要在不改变某个接口的时候，可以动态的给一个对象添加功能，要么是通过继承，生成子类的方法，另一种就是通过在对象外面包一层，同时不改变原来的接口，这样就可以通过包不同的装饰器，来动态的添加不同的功能。这就是装饰器模式的设计思想。</p>
<h3 id="装饰模式的优点"><a href="#装饰模式的优点" class="headerlink" title="装饰模式的优点"></a>装饰模式的优点</h3><ol>
<li>灵活性<br> 通过不同的组合方式，可以很容易的组合出不同的功能。</li>
<li>低耦合（独立性好<br> 被装饰的对象和装饰器相互独立，可以互相不知道彼此，耦合性低</li>
<li>方便<br> 装饰器可以动态的为对象添加功能，非常的方便</li>
</ol>
<h3 id="装饰模式的缺点"><a href="#装饰模式的缺点" class="headerlink" title="装饰模式的缺点"></a>装饰模式的缺点</h3><ol>
<li>会产生很多小的零碎的类</li>
<li>由于装饰器是一层包一层的，debug的时候会比较繁琐</li>
</ol>
<h3 id="装饰模式的应用场景"><a href="#装饰模式的应用场景" class="headerlink" title="装饰模式的应用场景"></a>装饰模式的应用场景</h3><p>在JAVA中的InputStream和OutputStream就运用了装饰器模式</p>
<ol>
<li>想要动态的给一个对象添加各种不同的功能的时候</li>
<li>不想用继承的方式为对象添加功能的时候（这么一看，装饰模式也算是继承的替代</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://book.douban.com/subject/26933281/" target="_blank" rel="external">图解设计模式</a><br><a href="https://book.douban.com/subject/4260618/" target="_blank" rel="external">设计模式之禅</a><br><a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/decorator.html" target="_blank" rel="external">图说设计模式-装饰模式</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <p class="site-author-name" itemprop="name">ningge</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ningge</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

  
  <script type="text/javascript" count="50" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
